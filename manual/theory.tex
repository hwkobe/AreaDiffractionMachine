\chapter{Detector Geometries}\label{theory_chapter}

X-ray diffraction can be modeled as in figure~\ref{DiffractionSetup}. 
Cones of light preferentially leave a crystal and Usually, the 
interesting thing to measure with x-ray 
diffraction is the scattering angle 
$2\theta$. If a detector was placed perpendicular 
to the incoming beam, the cones of light would be detected as 
circles of high intensity. 
If the distance $d$ 
from the sample to the detector was and 
the distance $r$ from the center of the detector to a 
particular ring were known, the scattering angle could
be calculated as
\begin{equation}
    \tan2\theta = \frac{r}{d}.
\end{equation}
This is shown in figure~\ref{MeasureAngleFlatDetector}. 
Life is not always so simple. The detector is never
exactly perpendicular to the incoming beam.  In practice, 
the detector will always be slightly titled with respect 
to the incoming beam. Failing to account for this would
introduce a systematic error in the angle measurements.

\begin{SCfigure}[1][bthp]
    \centering
    \input{figures/DiffractionSetup.tex}
    \caption{An X-Ray diffraction setup. X-rays scatter from a 
    sample and are captured by a detector.}
    \label{DiffractionSetup}
\end{SCfigure}

\begin{SCfigure}[1][bthp]
    \centering
    \input{figures/MeasureAngleFlatDetector.tex}
    \caption{The same setup as in figure~\ref{DiffractionSetup}. 
    $2\theta$ is the scattering angle of the light,
    $d$ is the distance 
    from the crystal to the detector, and $r$ is the distance 
    from the center of the detector.}
    \label{MeasureAngleFlatDetector}
\end{SCfigure}

There is a need to analyze diffraction data on detectors that are 
not perpendicular to the incoming x-rays. We will present a 
theory of tilted detectors first developed by Abhik Kumar\cite{Kumar05}.
\index{Abhik Kumar} Our derivation will result in 
different formulas because of different assumptions
about how the detector is tilted. This is actually a very important
point because version 1 of the program uses Abhik's formulas for
geometric transforms whereas the equations derived in the manual
were only implemented in version 2 of the program.
Section~\ref{note_about_versions} discusses this situation in
more detail.

We are interested in relating
coordinates on a tilted detector 
to theoretically motivated quantities such as 
the scattering angle of the beam that hit the
point. We must first work
out the transformation of points on a tilted detector
to points on an untilted detector. This is to say
that we want to figure out where on an untilted 
detector a beam would have hit were it to hit
the untilted detector instead of the tilted detector.
We will call the point on the untilted detector
as measured on the untilted detector $(x,y)$ 
and the corresponding point on the tilted detector
as measured on the tilted detector $(x''',y''')$. 
The reason for the three primes will become obvious
shortly. This is shown in 
figure~\ref{PhysicalSetup}. Another way to think
about this is to imagine putting your 
head at the crystal and looking directly 
at some point on a real
detector. We want to figure out
the corresponding point that would be seen be looking
at the imagined untilted detector.

\begin{SCfigure}[1][bthp]
    \centering
    \input{figures/PhysicalSetup.tex}
    \caption{The detector 
    is titled with respect to the 
    incoming beam. We are interested in relating
    the point on the tilted detector $(x''',y''')$ to the
    point $(x,y)$ on the imagined untilted detector.}
    \label{PhysicalSetup}
\end{SCfigure}

\section{The Three Rotation Angels}
\index{$\alpha$} \index{$\beta$} \index{Rotation} \index{Tilt}
In order to relate these points, we need to find a way to 
describe an arbitrary tilt. We will 
characterize a titled detector as an untitled detector
that has 3 successive rotations applied to it. 
We will first rotate the detector about the detector's $y$
axis. We will then rotate the detector about the detectors
new $x'$ axis. Finally, we will rotate the detector about
a vector normal to the detector going through its center.
These rotations are shown in figure~\ref{ThreeTilts}.
We can solve our original problem if we deal
with each rotation separately.

\begin{figure}[htb]
    \centering
    \subfloat[$\beta$ characterizes
    a rotation around the $\hat{y}$ axis.]{
    \label{beta}\input{figures/BetaRotation.tex}}\hspace{1em}
    \subfloat[$\alpha$ characterizes
    a subsequent rotation around the new $\hat{x}'$ axis.]{
    \label{alpha}\input{figures/AlphaRotation.tex}}\hspace{1em}
    \subfloat[$R$ characterizes the subsequent rotation about
    a vector normal to the plane.]{
    \label{R_fig}\input{figures/Rotation.tex}}
    \caption{Any detector tilt can be characterized 
    by three successive rotations.}
    \label{ThreeTilts}
\end{figure}

\section{\texorpdfstring{The $\beta$ Rotation}{The beta Rotation}}

\begin{figure}[htb]
    \centering
    \subfloat[]{\label{PitchX_A}\input{figures/PitchX_A.tex}} 
    \hfill
    \subfloat[]{
    \label{PitchX_B}\input{figures/PitchX_B.tex}}
    \caption{The untilted detector is rotated by $\beta$ around
    $\hat y$.}
    \label{PitchX}
\end{figure}

We first apply to our untitled detector a rotation 
around $\hat{y}$ by angle $\beta$.
We begin with a point $(x,y)$ on an
untilted detector and relate it to its corresponding point 
$(x',y')$ on the rotated detector.
A diagram of this is shown in figure~\ref{PitchX}.  
We can use the geometry of these diagrams 
to relate these coordinates. Using
similar triangles:
\begin{equation}
    \frac{x}{d}=\frac{x'\cos\beta}{d+x'\sin\beta}.
\end{equation}
Or
\begin{equation}\label{xTermsxPrime}
    \boxed{x = \frac{dx'\cos\beta}{d+x'\sin\beta}}.
\end{equation}
Again, we have
\begin{align}
    \frac{y}{a}&=\frac{y'}{a+b}\\
    \frac{d}{a}&=\frac{d+x'\sin\beta}{a+b}.
\end{align}
So
\begin{equation}\label{yTermsxPrime}
	\boxed{y= \frac{dy'}{d+x'\sin\beta}}.
\end{equation}
Equation~\ref{xTermsxPrime} and \ref{yTermsxPrime} are 
the equations relating a point on an
untilted detector to the corresponding point 
on a tilted detector.

\section{\texorpdfstring{The $\alpha$ Rotation}{The alpha Rotation}}

We take the point $(x',y')$ on the plane rotated by $\beta$
around $\hat y$ and relate it to the point $(x'',y'')$ on a
plane then rotated by $\alpha$ around $\hat{x}'$. 
Figure~\ref{PitchY_A} is a diagram this plane.
Figure~\ref{PitchY_B} is a more geometrical diagram and
figure~\ref{PitchY_C} shows a cross section of the $y=0$
plane.

\begin{SCfigure}[1][bthp]
    \centering
    \input{figures/PitchY_A.tex} 
    \label{PitchY_A}
    \caption{A diagram of a plane that has been 
    rotate by angle $\beta$ about the $\hat y$ axis 
    and then by $\alpha$ about the $\hat x'$ axis.}
\end{SCfigure}

\begin{SCfigure}[1][bthp]
    \centering
    \input{figures/PitchY_B.tex} 
    \label{PitchY_B}
    \caption{A more geometrical diagram
    of figure~\ref{PitchY_A}.}
\end{SCfigure}

\begin{SCfigure}[1][bthp]
    \centering
    \input{figures/PitchY_C.tex} 
    \label{PitchY_C}
    \caption{A cross section of the $y=0$ plane.}

\end{SCfigure}

From figure~\ref{PitchY_C}, we see  
that $f=y''\sin\alpha\cos\beta$. From figure~\ref{PitchY_B},
we see that $h=y''\cos\alpha$. Using similar
triangles:
\begin{equation}
    \frac{y}{a} = \frac{y''\cos\alpha}{a+b+c}.
\end{equation}
Again:
\begin{equation}
    \frac{d}{a} = \frac{d+x''\sin\beta+f}{a+b+c}.
\end{equation}
We deduce that
\begin{equation}\label{ytermsydoubleprime}
    \boxed{y=\frac{dy''\cos\alpha}{
    d+x''\sin\beta+y''\sin\alpha\cos\beta}}
\end{equation}
Figure~\ref{PitchY_C} shows that 
$g=y''\sin\alpha\sin\beta$ and that 
$x''\cos\alpha=l+g$. Using similar triangles again 
\begin{equation}
    \frac{x}{d} = \frac{l}{d+x''\sin\beta+
    y''\sin\alpha\cos\beta}
\end{equation}
Plugging in and simplifying
\begin{equation}\label{xtermsxdoubleprime}
    \boxed{x=\frac{d(x''\cos\beta-y''\sin\alpha)}{
    d+x''\sin\beta+y''\sin\alpha\cos\beta}}
\end{equation}

\section{\texorpdfstring{The $R$ Rotation}{The R Rotation}}

The final rotation is by angle $R$ about a vector normal
to the plane. We relate the coordinate $(x'',y'')$ on the 
previously rotated detector to the point $(x''',y''')$ on 
a detector then rotated about its center:
\begin{align}
    x''&=x'''\cos R + y'''\cos R\label{rotation1}\\
    y''&=y'''\cos R - x'''\cos R\label{rotation2}
\end{align}
Applying equation~\ref{rotation1} and \ref{rotation2}
to equation \ref{xtermsxdoubleprime} and \ref{ytermsydoubleprime}
gives us the needed relationship between a point on an untilted
detector and the corresponding point on a tilted detector.

\section{Pixel Coordinates}

$(x''',y''')$ represents the distance between the center 
and a point on the real detector. We do not actually
measure this distance. What we experimentally measure
are pixel coordinates on a detector. There is some pixel 
coordinate corresponding to the center of
the detector\footnote{This is the point that the x-rays would
hit were they not to diffract off the crystal}. We will call 
it $(x_c,y_c)$.  We will call $(x_d,y_d)$ the 
pixel coordinate on the detector
that corresponds to the point $(x''',y''')$.
We want to relate ($x_d,y_d$) to $(x''',y''')$.
There is some material property of the detector 
called the pixel length ($pl$) that describes the width of each pixel
(e.g. \unit[1000]{mm/pixel}). There is a corresponding
quantity $ph$ that is the height of each pixel.
We can relate the pixel coordinates to the physical distances
by
\begin{align}\label{conversionToPixels}
    x'''&=(x_d-x_c) \times pl, &
    y'''&=(y_d-y_c) \times ph.
\end{align}

\section{Inverting the Equations}

We can invert these formula to learn what
$x''$ and $y''$ are in terms of $x$ and $y$.
We have:
\begin{equation}\label{invertx}
    x''=\frac{dx}{d\cos\beta-x\sin\beta-
    \cos\beta(x\cos\beta+d)/(\tfrac{x}{y}\cot\alpha+1)}
\end{equation}
and
\begin{equation}\label{inverty}
    y''=\frac{dx\cos\beta/(\tfrac{x}{y}\cos\alpha+\sin\alpha)}
    {d\cos\beta-x\sin\beta-
    \cos\beta(x\cos\beta+d)/(\tfrac{x}{y}\cot\alpha+1)}.
\end{equation}

\section{\texorpdfstring{$Q$, $2\theta$, and $\chi$}{Q, 2theta, and chi}}

We now have a way to relate $(x''',y''')$, 
a point on a detector rotated by angle $\beta$, 
$\alpha$, and $R$ to a point $(x,y)$
on an untilted detector.
We now relate $(x,y)$ to theoretically motivated 
quantities. Figure \ref{TwoTheta} shows that
$2\theta$, the angle of scattering 
of a beam, is 
\begin{equation}\label{2thetatermsr}
    \tan2\theta = \frac{r}{d} = \frac{\sqrt{x^2+y^2}}{d}.
\end{equation}
$\chi$, the angle around the beam, is calculated 
as\footnote{Actually, it is a little more complicated
then just this formula. Really, when viewing the diffraction
pattern from where the sample is, we want $\chi$ to equal 0 
pointing directly to the right and we want for it to 
increase in a 
counterclockwise direction. This is just like the 
definition of $\theta$ in Cartesian coordinates. 
To make $\chi=0$ to the right, we need to account for the 
fact that a rotation by angle $R$ will offset where $\chi$ 
equals 0 by adding the value of $R$ to $\chi$.
Then, our previous definition of $\chi$ makes $\chi$ 
increase in a
clockwise direction. (The reason is because we define $y$
to increase as you go down the detector). To make $\chi$ 
increase in the counterclockwise direction, we need to 
multiply by negative 1. When we do this, our real $\chi$ is 
related to the chi derived above by $-1\times(\chi+R)$
It would probably be cleaner to get rid of this final
multiplication by changing the definition so
that $y$ increased as you go up the detector, but this
way is good enough.}
\begin{equation}\label{chitermsyx}
    \tan\chi = \frac{y}{x}.
\end{equation}
$Q$ is calculated as
\begin{equation}\label{qterms2theta}
    Q = 4\pi \sin(2\theta/2)/\lambda.
\end{equation}

\begin{SCfigure}[1][bthp]
    \centering
    \input{figures/TwoTheta.tex}
    \caption{For a particular point $(x,y)$ on an 
    untilted detector, we define $2\theta$ as the angle of 
    scattering of the beam and $\chi$ as the
    azimuthal angle of the scattered light around 
    the beam.}
    \label{TwoTheta}
\end{SCfigure}

We could use incoming beam's energy instead of its wavelength 
using De Broglie's formula
\begin{equation}
    E = hc/\lambda.
\end{equation}
Some people use the quantity $D$ instead of $Q$
\begin{equation}\label{DtermsQ}
    D = 2\pi/Q.
\end{equation}

If we knew $x_c$, $y_c$, $pl$, $ph$, $d$, $\lambda$,
$\alpha$, $\beta$, and $R$ for an experiment, could
relate pixel coordinates $(x_d,y_d)$ read directly off
of a detector to the
theoretically motivated quantities $Q$ and $\chi$.
A discussion of how these detector parameters can be 
determined experimentally
is given in section~\ref{calibration}.

\section{A Note About Versions}\label{note_about_versions}

Version 1 of the program uses the equations derived
by Abhik in \cite{Kumar05}. For reference, Abhik's 
derivation is different in that 
equation~\ref{ytermsydoubleprime} and \ref{xtermsxdoubleprime} 
are replaced with the equations
\begin{align}
    x &= \frac{dx''cos\beta}{d+y''\sin\alpha+x''\sin\beta}, &
    y &= \frac{dy'''\cos\alpha}{d+y''\sin\alpha+x''\sin\beta}.
\end{align}
These equations must also be inverted to replace \ref{invertx}
and \ref{inverty}. But other that,
the rest of the discussion above is exactly the same using Abhiks' 
method.

Beginning with version 2 of the program, 
equation~\ref{ytermsydoubleprime} and \ref{xtermsxdoubleprime}
derived earlier are used for the transforms.
So technically, version 1 and version 2 of the program are not
interchangeable and certain quantities calculated with one of
the versions of the program, such as calibration parameters,
can not be used in the other version of the program.
But in practice, both sets of equations reduce to each other in the 
small $\alpha$ and $\beta$ limit which is almost always the case when
performing powder diffraction. So it is very unlikely that this
switch between version 1 and version 2 would cause any difficulty.


\section{Implementation In Code}

For reference, this section present the C source 
code used in the computer program to perform the 
transformation from pixel values on a tilted 
detector to $(Q,\chi)$ and back again. 
This code uses the equations derived in this manual
for the geometric transforms and the code was introduced 
in version 2 of the program. Version 1 uses different
code using Abhik's formulas for the geometric transform.

Below is the function
\code{getTwoThetaChi()} which converts real pixel
coordinates $(x_d,y_d)$, called \code{xPixel}
and \code{yPixel} on the detector, into the values 
$2\theta$ and $\chi$, called \code{twoTheta} and 
\code{chi} using the equations described above. 
\begin{lstlisting}
/*
 * This transformation is done using Josh's equations derived
 * in the software manual. The notation in the manual 
 * corresponds to the variable names by:
 *   xMeasured = x'''
 *   yMeasured = y'''
 *   xPhysical = x_d
 *   yPhysical = y_d
 */
void getTwoThetaChi(double xCenter,double yCenter,
        double distance,double xPixel,double yPixel,
        double pixelLength,double pixelHeight,
        double rotation,double cos_beta,double sin_beta,
        double cos_alpha,double sin_alpha,
        double cos_rotation,double sin_rotation,
        double *twoTheta,double *chi) {

    double pixelLength_mm,pixelHeight_mm;
    double xMeasured,yMeasured;
    double bottom;
    double xPhysical,yPhysical;

    // pixellength comes in in units of micron
    // We convert pixelLength & pixelHeight into mm units so 
    // that they are comparable with distance (in units of 
    //  millimeters)
    pixelLength_mm = pixelLength/1000.0;
    pixelHeight_mm = pixelHeight/1000.0;
    
    xMeasured = (xPixel-xCenter)*pixelLength_mm;
    yMeasured = (yPixel-yCenter)*pixelHeight_mm;

    bottom = distance+(xMeasured*cos_rotation+ 
            yMeasured*sin_rotation)*sin_beta+
            (-xMeasured*sin_rotation+
            yMeasured*cos_rotation)*sin_alpha*cos_beta;
    
    // calculate the x y coordinates on the imaginary 
    // detector using fancy math
    xPhysical = distance*((xMeasured*cos_rotation+
            yMeasured*sin_rotation)*cos_beta
            -(-xMeasured*sin_rotation+
            yMeasured*cos_rotation)*sin_alpha)/bottom;

    yPhysical = distance*(-xMeasured*sin_rotation+
            yMeasured*cos_rotation)*cos_alpha/bottom;

    *twoTheta = atan2(sqrt(xPhysical*xPhysical+
            yPhysical*yPhysical),distance);
    // Convert to radians
    *twoTheta = *twoTheta * 180.0/PI;

    // explicitly convert chi to degrees
    *chi=atan2(yPhysical,xPhysical)*180.0/PI;
    
    // then add rotation to it so that chi always points 
    // to the right. Also, we have to multiply chi by -1 
    // because we have been defining our angles the inverse 
    // of the way they should be. There is a probably a 
    // better way to do this if I really thought through 
    // exactly how chi is defined. For the moment, through, 
    // this does exactly the right thing.
    *chi = (*chi + rotation)*(-1);

    // make sure that chi is b/n 0 and 360
    *chi = mod(*chi, 360.0);
}
\end{lstlisting}
As described above, the program must be given
the values $x_c$, $y_c$, $ps$, $d$, $\alpha$, 
$\beta$, and $R$ in order to perform the 
transformations.  
For $x_c$ and $y_c$, 
the function takes in the variables $xCenter$ and
$yCenter$. The program takes in \code{pixelLength} 
and \code{pixelHeight} for $pl$ and $ph$. The program 
takes in the sines and cosines of $\alpha$, $\beta$, and 
$R$ so that the sin of $\alpha$ can be cached for increased
efficiency. This function calculates $2\theta$ instead
of $Q$ or $D$ but it is trivial to do the conversion.

The listing below presents the function \code{getXY()} 
which does the inverse transformation of 
the above function. It uses the same
terminology for parameters above:
\begin{lstlisting}
/*
 * This transformation is done using Josh's equations derived
 * in the software manual. The notation in the manual 
 * corresponds to the variable names by:
 *   xMeasured = x'''
 *   yMeasured = y'''
 *   xPhysical = x_d
 *   yPhysical = y_d
 */
void getXY(double xCenter,double yCenter,double distance,
        double energy,double q,double chi,double pixelLength,
        double pixelHeight,double rotation,double cos_beta,
        double sin_beta,double cos_alpha,double sin_alpha,
        double cos_rotation,double sin_rotation,
        double * xPixel,double * yPixel) {

    double wavelength;
    double twoTheta;
    double xPhysical,yPhysical;
    double bottom;
    double pixelLength_mm,pixelHeight_mm;
    double xMeasured,yMeasured;

    double tan_chi;

    wavelength = 12398.4172/energy;

    // rotate chi back to point whatever way it is supposed 
    // to point
    chi = chi*(-1) - rotation;

    chi = mod(chi, 360.0);
    
    // explicitly convert chi to radians
    chi*=PI/180.0;

    twoTheta = 2.0*asin(wavelength*q/(4.0*PI));

    tan_chi = tan(chi);
    xPhysical = fabs(distance*tan(twoTheta)/sqrt(1.0+
            tan_chi*tan_chi));

    // one must determine explicitly the sign of xPhysical 
    // by inspecting the diagram. This is b/c at one point 
    // we take a sqrt in our derivation.
    if (chi>PI/2.0 && chi<3.0*PI/2.0) 
        xPhysical = -1.0*xPhysical;

    yPhysical=fabs(xPhysical*tan_chi);

    // set the sign of y explicitly
    if (chi > PI && chi < 2.0*PI)
        yPhysical = -1.0*fabs(yPhysical);

    // I should worry about cos_alpha being 0
    bottom = distance*cos_beta-xPhysical*sin_beta-
            cos_beta*(xPhysical*cos_beta+distance)/(
            (xPhysical*cos_alpha)/(yPhysical*sin_alpha)+1);

    xMeasured = (distance*xPhysical*cos_rotation-
            distance*xPhysical*cos_beta*sin_rotation/
            (xPhysical*cos_alpha/yPhysical+sin_alpha))/
            bottom;

    yMeasured = (distance*xPhysical*sin_rotation+ 
            distance*xPhysical*cos_beta*cos_rotation/
            (xPhysical*cos_alpha/yPhysical+sin_alpha))/
            bottom;

    // convert pixelLength & pixelHeight into mm units so 
    // that they are comparable with distance (in units of 
    // millimeters)
    pixelLength_mm = pixelLength/1000.0;
    pixelHeight_mm = pixelHeight/1000.0;

    *xPixel = xMeasured/pixelLength_mm + xCenter;
    *yPixel = yMeasured/pixelHeight_mm + yCenter;
}
\end{lstlisting}
