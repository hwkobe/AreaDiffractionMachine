\section{Calibration}

The \gui{Calibration} tab can be used to load
diffraction data into the program. The tab can
be used to calibrate diffraction data to determine the 
experimental parameters that characterize the experiment. 
The data can be loaded using the \gui{Data File:} input. 
The program recognizes \macroline{mar2300}, \macroline{mar3450}, 
\index{Mar2300}\index{Mar3450}\index{MarCCD}\index{Tiff}
\macroline{mccd}, and \macroline{tiff}, and \macroline{edf} data. 
Multiple files can be loaded into the program
by selecting multiple files with the file selector.
The sum image will be used.

This program characterizes a diffraction experiment 
according to the parameters:
\index{Calibration Parameters}
\index{X Center}\index{Y Center}
\index{Detector Distance}\index{$\alpha$}
\index{$\beta$}\index{Rotation}\index{Pixel Scale}
\begin{itemize}
    \item \gui{xc:}, \gui{yc:} - the $x$ 
and $y$ coordinates on the detector where the incoming 
x-ray beam would have hit the detector were there 
no sample in the way (in pixels).
    \item \gui{d:} - the distance from the sample to 
    detector (in mm).
    \item \gui{E:} - the energy of the incoming beam (in eV).
    \item \gui{alpha:}, \gui{beta:} 2 tilt parameters of 
    the detector (in degrees).
    \item \gui{R:} - the rotation of the detector 
    around the center (in degrees).
    \item \gui{pl:} - the pixel length of the image. 
    The width of one pixel (in microns).
    \item \gui{ph:} - The pixel height of the image. 
    The height of one pixel (in microns).
\end{itemize}
Before calibrating an image, three things must be done. 
First, the calibration data must be loaded.
Second, a $Q$ data file with the standard $Q$ values for the
sample must be loaded.
Third, an initial guess of the calibration parameters must be
loaded. This can be done with the \gui{Parameters} inputs. A
decent guess at the calibration parameters can sometimes
be found in the header of a diffraction file. These values
can be loaded into the program using the \gui{Get From Header} 
button to.  The \gui{Do Fit} button will perform the calibration 
and find a best guess at the real experimental parameters.

The \gui{Work in Lambda} selection in the \gui{Calibration} menu can
be used to switch the program to work with the x-ray's
wavelength instead of its energy. The relationship 
between these values is $E=hc/\lambda$. The calibration parameter 
\gui{E:} will be replaced with \gui{$\lambda$:} and the current 
value will be converted. 

The \gui{Q Data:} input lets you load in standard $Q$ data files. 
This program stores several standard $Q$ files. The can be selected
through the \gui{Standard Q} menu in the \gui{Calibration} menu.

The calibration fit can be modified in a couple of ways.
The calibration algorithm will look 
the diffraction data to find diffraction peak. It does so by
running from the center of the image out. 
The number of peaks that the program tries to find can be
set with the \gui{Number of Chi?} input.
This tells the program how many of these radial slices from 
the center of the image should be done. The \gui{Stddev?} input 
tells the program what ratio higher the peak must be then the 
standard deviation of the background near the peak in order for the
peak to be considered real. The higher the value, the more
picky the program is about finding legitimate peaks.

If some of the experimental parmaetesr are known exactly, 
pushing the \gui{Fixed?} check box will fix the associated 
variable so that it will be not refined when fitting. The pixel 
length and pixel height can never be refined so this does not
apply for them.

To see how good the current calibration parameters are at
characterizing the loaded data, the \gui{Draw Q Lines?} 
check box can be used to make the program draw
on the diffraction image lines of constant $Q$ specified
by the $Q$ data file. The $\Delta Q$ ranges specified in 
the $Q$ file can also be drawn using the \gui{Draw dQ Lines?} 
check box. The \gui{Draw Peaks?} check box can be used to 
display on top of the diffraction image all of the peaks that
were found while doing the fit.

The diffraction image can be zoomed into by left clicking
in the image, dragging your mouse, and then releasing.
The image can be zoomed out of by right clicking on the image. 
The image can be panned across by shift clicking on the image 
and dragging. The image can be made bigger or smaller by 
resizing the window.

In the file menu, the \gui{Save Image} option can be used 
to save the current diffraction file in several popular
image formats. The image will be saved with the current
zoom level and any $Q$ lines, $\Delta Q$ lines, peaks, or
masks drawn on top of it.

\section{Masking}
\index{Pixel Masking}

You can make the program ignore certain pixels when doing
diffraction analysis. This is all done on the \gui{Masking}
tab. To have the program ignore pixels above or below a 
certain value, use the threshold masking option.
You can have the program ignore all pixels that are larger 
then a certain value by selecting 
\gui{Do Greater Than Mask?} and putting the particular value
into the \gui{(Pixels Can't Be) Greater Than Mask:} input.
You can have the program ignore all pixels less than a certain
value with the corresponding \gui{Do Less Than Mask?}
and the \gui{(Pixel's Can't Be) Less Than Mask:} input.
Once you set the threshold, these any pixel either too large
or too small will be displayed on the diffraction and cake
displays as a different color. That color is user 
specified by the color inputs next to the checkboxes. 
When you do an intensity integration, these pixels are 
not used in the averages.

You can also have the program mask certain whole areas 
of the image if those pixels are undesirable for some 
reason. If you wish to do so, select the 
\gui{Do Polygon Mask?} option. To draw the image on the
screen that you do not want, click \gui{Add Polygon} and
then then left click on the diffraction image for each 
of the vertices of the polygon that you want to mask out.
To draw the final vertex and finish the polygon, just
use right click. To remove any polygon, push the 
\gui{Remove Polygon} button and click on the polygon that
you want to get rid of. You can remove all the polygons
in the program using the \gui{Clear Mask} button, save
all the polygons in the program to a file using the
\gui{Save Mask} button, and load saved polygons using
the \gui{Load Mask} button.

\section{Cake}
\index{$\chi$}\index{$Q$}\index{Cake}
A caked image is a plot of diffraction data in $Q$, 
$\chi$ space. $\chi$ is a measure of the angle around 
what would be the incoming x-ray beam if the beam was 
not scattered. By convention, $\chi$ is equal to 0
degrees to the right of the pixel center of the image 
and increases while going counterclockwise. To cake the
data, you need to give the program a range and bin size 
in both $Q$ and $\chi$. When you push \gui{Do Cake}, the
program will present a new window with the caked data in
it. You can interact with the cake image just like with
the diffraction image described above. If you have one of
the \gui{Draw Q Lines}, or \gui{Draw dQ Lines} or 
\gui{Draw Peaks} boxes selected from the \gui{Calibration} 
tab, these will also be drawn on the cake image. In particular,
the $Q$ and $\Delta Q$ lines are just vertical lines on the
caked image. You can save the caked data as plain text 
using the \gui{Save Data} button. You can save the caked 
image as a popular image format using the \gui{Save Image}
button. The image will have the $Q$ lines and peaks saved
in the image if that option is selected when saving.

You can also apply a polarization correction to the caked
data using the \gui{Do Polarization Correction?} check box
and the \gui{P?} input. The formula to calculate a 
polarization correction is:
\begin{eqnarray}
    I&=&Im/PF \\ 
    PF&=&P(1 - (\sin(2\theta)\sin(\chi-90))^2) + 
    (1 - P)(1 - (\sin(2\theta)\cos(\chi-90))^2)
\end{eqnarray}
with $Im$ the measured intensity. There is a convenient
feature called AutoCake which picks a range of $Q$ and $\chi$ 
values and then cakes that range. AutoCake will pick the
smallest cake range so that the whole image shows up in
the cake. It will pick the bin size so that each pixel 
displayed on the screen corresponds to a single bin.

\section{Integrate}
\index{Intensity Integration}
Intensity integration lets you calculate average intensity
as a function of $Q$, $\chi$, or $2\theta$. By default, the
option is to integrate in $Q$ or $\chi$. If you want to 
integrate in $2\theta$, you must click on the integrate 
option of the menu and select \gui{Work in 2theta} instead
of \gui{Work in Q}. To integrate intensity, you need to
give a lower value, an upper value, and a bin size. With 
these inputs, the \gui{Integrate} button will perform the
integration. This data will be plotted in a new window.
By default, the integration will be over all possible values
of the other independent variable. If you integrate in $Q$,
it will be for all $\chi$. This can be changed by using the
constrain checkboxes. For example, to integrate in $Q$ only
for the $\chi$ values between 0 and 90, you would select the
\gui{Constraint With Range on Right?} option and the put in
the \gui{Chi Lower?} input the value 0 and the \gui{Chi Upper?}
input the value 90.  When you then pushed the integrate button, 
the program would apply the proper constraints.

You can apply the same sort of polarization correcting when 
integrating. You can also save integration data using the
\gui{Save Data} button. The output file will be many rows
of two column plain text data. 

\section{Macro}\index{Macros}
If you want to perform a complicated task many times, the
easiest thing to do is to record a macro of all the commands
and then run the macro instead of doing everything by hand.
To record a macro, go into the Macro part of the menu and
select \gui{Start Record Macro}. After doing the tasks you
want recorded, push \gui{Stop Record Macro} and can save 
these macro commands to a text file. To run a macro file,
you can go into the Macro part of the menu and select
\gui{Run Saved Macro}. 

By editing macro files by hand, you can make them much more
useful. Most macro commands are just the name of the GUI item
possibly followed by whatever that thing would want (like a 
filename or number). The macro command to load a diffraction 
file is \macroline{Data File:} followed by a line with a
filename such as \macroline{C:/somefolder/thefile.mar3450}.
The filename line can be replaced by a list of filenames,
a directory containing diffraction data, or some combination
of both. The program will run the subsequent macro lines on
every file given in the list and on all diffraction files found 
in any folders given in the list. The loop over diffraction
files will end with a subsequent \macroline{Data File:} line,
a \macroline{END LOOP} line, or the end of the macro file.

When lopping over diffraction files, there is a special 
markup which makes it easy to save files into the right 
place. This can be done with the special markup names
\macroline{BASENAME} and \macroline{FILENAME}. Whenever the
program runs across \macroline{BASENAME} in the macro file,
that string will be replaced with the current base of the 
diffraction file that has been loaded. Similarly, 
\macroline{FILENAME} will get replaced with the filename of
the current diffraction file. In our previous example,
\macroline{BASENAME} would get replaced with
\macroline{C:/somefolder} and \macroline{PATHNAME} would get 
replaced with \macroline{thefile}. You could recreate the 
original file name with \macroline{PATHNAME/FILENAME.mar3450}.
This markup can be used to save things with useful names. For
example, the macro line \macroline{Save Integration Data}
followed by the line
\macroline{PATHNAME/FILENAME\_int.dat} would, for
our previously loaded file, save the integrated intensity data
as \macroline{C:/somefolder/thefile\_int.dat}. For
all other diffraction data being looped over, the diffraction data
would get saved next to the corresponding data file.
