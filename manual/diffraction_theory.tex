\begin{SCfigure}
\centering
\input{figures/DiffractionSetup.tex}
\caption{An X-Ray diffraction setup. X-rays scatter from a 
3-D sample and are captured by a 2-D detector. In this 
setup, the detector is perpendicular to the incoming 
x-ray beam.}
\label{DiffractionSetup}
\end{SCfigure}

\begin{SCfigure}
\centering
\input{figures/MeasureAngleFlatDetector.tex}
\caption{The same setup as in figure~\ref{DiffractionSetup}. 
Here, $2\theta$ is the scattering angle, $d$ is the distance 
from the crystal to the detector, and $r$ is the distance 
from the center of the detector to some particular point 
(which $2\theta$ is associated with). Note that by center 
of the detector, we mean the point on the detector where 
the beam would hit if did not interact with the crystal.}
\label{MeasureAngleFlatDetector}
\end{SCfigure}

X-ray diffraction is the process of shining a beam of 
high energy x-rays at a regular crystal. This can be 
modeled simply as in figure~\ref{DiffractionSetup}. 
What we have is a series of cones of light that 
emminate preferentially at certain angles normal to 
the outgoing beam. These cones of light are then 
detected by a flat detector, as is shown in the 
diagram. Usually, the interesting thing to measure 
when doing x-ray diffraction are the angles of these 
cones of light. By convention, this angle is called 
$2\theta$. Were the detector to be perfectly perpendicular 
to the incomming beam, as in figure~\ref{DiffractionSetup}, 
our cones of light would be detected as circles of high 
intensity. Were we to know certain experimental parameters 
such as the distance from the sample to the detector and 
the distance from the center of the detecor to a 
particular ring (or really any point on the detector), 
we could easily calculate the scattering angle of light 
that ended up at that particular spot on the detector. 
Suppose that the distance from the crystal to the detector 
is $d$ and the distance from the center of the detector 
to our particular point on the detector is $r$, as is 
shown in figure~\ref{MeasureAngleFlatDetector}. Then the 
scattering angle will be calculated as
\begin{equation}
    \tan2\theta = \frac{r}{d}
\end{equation}
Unfortunnatley, life is not always as simple as this and 
sometimes things get a little bit more complicated. In 
particular, the assumption taht the detector is exactly 
perpendicular to the incomming beam in unphysical. It 
will unphysical because perfect alignment can never be 
acheived and the detector will always in practice be 
slightly offset with respect to the incomming beam, even 
if only slightly. Failing to account for this tilt introduce 
a systematic error in measuring $2\theta$ and doing any other 
sort of data analysis. It is also unphysical because there 
are often good reasons to collect diffraction data from 
detectors at significant tilts . The main reason why this 
is done is to collect data at more extreme angles without 
needing to user larger detectors. This rational is made 
intuitive in figure~\ref{HigherQValues}. So there is a 
need to analyze detectors with tilted geometires. I will 
here present this theory of tilted detectors as it was 
developed by Abhik Kumar in~\cite{Kumar05}.\index{Abhik Kumar}
I could simply refer you to this paper for the results
that I will cite, but this paper is, in my oppinion,
almost absolutely undecipherable. So to save you the
misery of pooring through it yourself, I will do
my best to cleanly work through his findings. 

\begin{SCfigure}
\centering
\input{figures/HigherQValues.tex}
\caption{This diagram illustrates how tilted geometries 
allow for the collection of diffraction data at more 
extreme angles without the need for a larger detector.}
\label{HigherQValues}
\end{SCfigure}

What we are interested in is mathematically describing 
position coordinates on a tilted detector by relating 
them to more theoretically motivated quantities such as 
the scattering angles that would lead to a beam hitting
that particular point on the detector. This will be 
the equation that is needed to do the diffraction 
analysis. In order to do this, we must first work
out the transformation of points on a tilted detector
to points on an untilted detector. This is to say
that we want to figure out where on an untilted 
detector the beam would have hit were it to hit
that untilted detector instead of the tilted detector.
We will call the point on the untilted detector
$(x,y)$ as it is measured on the untilted detector
and the point on the tilted detector
$(x''',y''')$ as measured by the tilted detector. 
The notation will become obvious
shortly. This is shown schematically in 
figure~\ref{PhysicalSetup}.


\begin{SCfigure}
\centering
\input{figures/PhysicalSetup.tex}
\caption{The setup of the experiment. Here, the detector 
is titled by some arbitrary angle with respect to the 
incoming beam. We will call some arbitrary point on 
the tilted detector as $(x''',y''')$. We are interested in 
relating this point to the point $(x,y)$ on some imagined 
untilted detector where a scattered beam would have hit 
were that tilted detector set up instead of the tilted
detector.}
\label{PhysicalSetup}
\end{SCfigure}

What we are interested in figuring out is a way of relating 
this point to some other point $(x,y)$ which would be on an 
imagined on a plane perpendicular to the incomming beam 
who's center coincides in 3 dimensional space with the 
center of the tilted detector.

\subsection{The Three Tilt Angels}
\index{$\alpha$}\index{$\beta$}\index{Rotation}
In order to relate these points, we need to find a way to 
describe some arbitrary tilt. To do so, we will need to 
have 3 tilt parameters. We will characterize these tilts 
by two orthogonal rotations about the $x$ and $y$ axis 
and one rotation about the center of the detector. These 
three angles are shown in action in figure~\ref{ThreeTilts}.

\begin{figure}
\centering
\subfloat[The tilt angle $\alpha$.]{
\label{alpha}\input{figures/AlphaRotation.tex}}
\subfloat[The tilt angle $\beta$.]{
\label{beta}\input{figures/BetaRotation.tex}}
\subfloat[The rotation angle $R$.]{
\label{R}\input{figures/Rotation.tex}}
\caption{Any detector rotation can be characterized 
as a rotation by both $\alpha$ and $\beta$.}
\label{ThreeTilts}
\end{figure}

In order to find this relationship, we will apply each of these 
rotations separately, one after another. And the combination 
of each of the three rotations will yield the total 
transformation.


\subsection{The $R$ Rotation}

\begin{SCfigure}
\centering
\input{figures/RotationFormula.tex}
\caption{This figure shows how points on a detector rotated 
by angle $R$ relate to the unrotated points. Remember that
a rotation of the plane is equivalent to the rotation of the
coordinates on the plane (which is what I have drawn).}
\label{RotationFormula}
\end{SCfigure}

We will first deal with the physical rotation by angle $R$ 
of the plane. What we have to deal with is the point $(x,y)$
on a plane being superimposed onto the point $(x',y')$ on 
another plane which is rotated by an angle $R$. This is shown
schematically in figure~\ref{RotationFormula}. The rotation of
the plane is mathematically equivalent to rotating the coordinates
and the equation describing the rotation of a plane is:
\begin{eqnarray}
    x&=&x'\cos R + y'cos R\\
    y&=&y'\cos R - x'cos R
\end{eqnarray}

\subsection{The $\beta$ Tilt}

\begin{figure}
\centering
\subfloat[]{\label{PitchX_A}\input{figures/PitchX_A.tex}} 
\hfill
\subfloat[]{
\label{PitchX_B}\input{figures/PitchX_B.tex}}
\caption{A diagram of the situation depicted in 
figure~\ref{PhysicalSetup} where only the 
$\beta$ rotation has been applied.}
\label{PitchX}
\end{figure}

We will now take the point $(x',y')$ and on the rotated plane 
and see what the coordinates of the corresponding point
$(x'',y'')$ would be if the point was projected onto another
plane titled by an angle $\beta$ around $\hat{y}$.
This is to say that we will figure out where on the tilted
plane a beam would hit were it not to hit that detector 
instead of the un-tilted detector.
This relationship is diagrammed in figure~\ref{PitchX}.  
We can use the geometry of these diagrams to figure out
the relationships between these coordinates. Using
the property of similar triangles, we see that
\begin{equation}
    \frac{x'}{d}=\frac{x''\cos\beta}{d+x''\sin\beta}.
\end{equation}
From this it follows that 
\begin{equation}\label{xTermsxPrime}
    \boxed{x' = \frac{dx''\cos\beta}{d+x''\sin\beta}.}
\end{equation}
Using similar triangles again, we see that
\begin{eqnarray}
    \frac{y'}{a}&=&\frac{y''}{a+b}\\
    \frac{d}{a}&=&\frac{d+x''\sin\beta}{a+b}.
\end{eqnarray}
from which it follows that
\begin{equation}\label{yTermsxPrime}
	\boxed{y'= \frac{dy''}{d+x''\sin\beta}.}
\end{equation}
So, equation~\ref{xTermsxPrime} and \ref{yTermsxPrime} give us 
the proper geometrical equations for relating a point on the 
un-tilted plane $(x',y')$ to the corresponding point 
$(x'',y'')$ on the tilted plane.


\subsection{The $\alpha$ Roll}
We can now take this point $(x'',y'')$ on the tilted 
plane and project it onto another plane which has both 
a tilt and roll by an angle $\alpha$ around $\hat{x}$ 
applied to it. This is to say that we can determine 
where beam that hit a point on the tilted detector 
would have hit were it to instead hit a tilted and 
rolled detector. This is shown schematically in 
figure~\ref{PitchY_A}. A more geometric view of 
the situation can be seen in figure~\ref{PitchY_B} and 
a cross section of the $x$
axis of this figure can be seen in figure~\ref{PitchY_C}.

\begin{SCfigure}
\centering
\input{figures/PitchY_A.tex} 
\label{PitchY_A}
\caption{In this figure, we see a tilted detector 
and then a detector which is both tilted and rolled
by an angle $\alpha$ around $\hat{x}$.}
\end{SCfigure}

\begin{SCfigure}
\centering
\input{figures/PitchY_B.tex} 
\label{PitchY_B}
\end{SCfigure}

\begin{SCfigure}
\centering
\input{figures/PitchY_C.tex} 
\label{PitchY_C}
\caption{A cross section of the x axis of 
figure~\ref{PitchY_A}. This figure helps bring out
the three dimensional aspects of that figure. }
\end{SCfigure}

The final equations relating $(x,y)$ to $(x''',y''')$ are 
\begin{equation}\label{xTermsXdoublePrime}
    x=\frac{d x'' \cos(\beta)}{d+y'' 
    \sin(\alpha) + x'' \sin(\beta)} 
\end{equation}
and
\begin{equation}
    y=\frac{d y'' \cos(\alpha)}{d+y'' 
    \sin(\alpha) + x'' \sin(\beta)}.
\end{equation}

$(x''',y''')$ is suppose to represent what we actually
measure on a real detector. Unfortunately, things are
not quite so easy. We do not actually measure these
values. The whole formalism assumes that we are 
measuring these distances from the point on the
detector where the beam would hit were it not to be
diffracted. Unfortunately, it is not at all clear
where this is. A discussion of finding the center will
be given in section~\ref{calibration}, but for now
lets simply note that there is some pixel on the detector
that is the center and worry about how to find it later. 
Lets call it $(x_c,y_c)$ 
We are now interested in some other pixel reading
on the detector which corresponds to the point
$(x''',y''')$. Lets call it $(x_d,y_d)$. Finally,
there is some material property of the detector 
describing the distance between each pixel
(e.g. \unit[1000]{mm/pixel}). We will call
this width $ps$. We can relate these quantities 
using:
\begin{align}\label{conversionToPixels}
    x'''&=(x_d-x_c) \times ps &
    y'''&=(y_d-y_c) \times ps
\end{align}
This means that, in terms of $(x_c,y_c)$ and $ps$,
we can relate $(x,y)$ and $(x_d,y_d)$ which are
directly measurable experimental quantities.


\subsection{Inverting the Equations}

We can invert these formula to get
\begin{equation}\label{ConvertToPrimed}
    x''=\frac{yd}{d\cos(\beta) - 
    x\sin(\beta)-y\cos(\beta)\tan(\alpha)} 
\end{equation}
and
\begin{equation}
    y''=\frac{xd \cos(\beta)/\cos(\alpha)}{d\cos(\beta) - 
    x\sin(\beta)-y\cos(\beta)\tan(\alpha)}.
\end{equation}

\subsection{$Q$, $2\theta$, and $\chi$}

\begin{SCfigure}
\centering
\input{figures/TwoTheta.tex}
\caption{For a particular point $(x,y)$, we
alwasy associate two quantities: $2\theta$ and $\chi$.
$2\theta$ is the angle of scattering 
of the beam, or the angle that an incomming beam is 
difflected by when it diffracts off the crystal. 
$\chi$ is a measure of the azimuthal angle around 
the beam. It tells you in what direction radially 
outwards (with respect to the undeflected beam) 
the outgoing beam was was scattered.}
\label{TwoTheta}
\end{SCfigure}

We now have a way of relating $(x''',y''')$, 
a point on a detector with a pitch $\beta$, 
tilt $\alpha$, and a roll $R$ applied to it, 
to a point on an an untilted detector $(x,y)$
where a beam of light would have interesected
were it not to hit the tilted detector.
With this relationship, we can now relate
these quantities to theoretically motivated 
quantities. In particular, the angle of scattering 
of a beam is by convention called $2\theta$ and a 
quanity measuring the scattering angle around the 
incomming beam is called $\chi$. These quantities 
are shown in figure~\ref{TwoTheta}. We can see that 
the relationship between $(x,y)$ and $2\theta$ and 
$\chi$ is
\begin{equation}
    \tan2\theta = \frac{r}{d} = \frac{x^2+y^2}{d}
\end{equation}
and
\begin{equation}
    \tan\chi = \frac{y}{x}
\end{equation}
The quantity $Q$ is often used instead of $2\theta$. 
they are related by
\begin{equation}
    Q = \frac{4\pi \sin(2\theta/2)}{\lambda}
\end{equation}
The reason for using $Q$ instead of $2\theta$ is because 
diffraction theory shows that the $Q$ values of preferential 
scattering of a crystal is a material property independent 
of the experimental setup (such as $d$ and $\lambda$). 

Alternately, energy could be used in this formula.
To do so, energy can be related to wavelength using
the De Broglie's formula
\begin{equation}
E = \frac{hc}{\lambda}
\end{equation}
Finally, sometimes people use the quantity $D$ instead.
$D$ is related to $Q$ by
\begin{equation}
    D = \frac{2\pi}{Q}
\end{equation}
Using equation~\ref{conversionToPixels},
we now have a way of relating pixel
coordiantes $(x_d,y_d)$ read directly off
of a detector to the
theoretically motivated coordinates $(Q,\chi)$.
In order to do this conversion, we must use
the values $x_c$, $y_c$, $ps$, $d$, $\lambda$,
$\alpha$, $\beta$, and $R$. A discussion of
how these values can be determined so that
this transformation can in practice be done
will be given in section~\ref{calibration}


\subsection{Implementation In Code}

For reference, this section present the C source 
code used in the computer program to perform the 
transformation from pixel values on a tilted 
detector to $(Q,\chi)$ and back again. 
Listing~\ref{getTwoThetaChi} presents the function
\code{getTwoThetaChi()} which converts real pixel
coordaintes $(x_d,y_d)$, called \code{xPixel}
and \code{yPixel}, into the values $2\theta$ and $\chi$, 
called \code{twoTheta} and \code{chi} using the 
transformation described above. In order to perform 
this transformation, the program must be given
the values $x_c$, $y_c$, $ps$, $d$, 
$\alpha$, $\beta$, and $R$. For $x_c$ and $y_c$, 
the function takes in the variables $xCenter$ and
$yCenter$. The program takes in \code{pixelLength} 
and \code{pixelHeight} for $ps$ to identify the
width and height of each pixel (which should be the 
same). The program takes in the sines and cosines
of $\alpha$, $\beta$, and $R$ to allow for increased
efficiency. These variables are called \code{ cos\_beta}
\code{sin\_beta},\code{cos\_alpha},\code{sin\_alpha},
\code{cos\_rotation}, and \code{sin\_rotation}. 
Note that this function calculates $2\theta$ instead
of $Q$ or $D$ but it takes a trivial amount of work
to the additional conversion.
\begin{lstlisting}[caption={The Code to convert pixel coordinates on a real detector into $(Q,\chi)$ coordinates},label=getTwoThetaChi]
void getTwoThetaChi(double xCenter,double yCenter,double distance,
        double xPixel,double yPixel,
        double pixelLength,double pixelHeight,double rotation,
        double cos_beta,double sin_beta,double cos_alpha,double sin_alpha,
        double cos_rotation,double sin_rotation,
        double *twoTheta,double *chi) {

    double pixelLength_mm,pixelHeight_mm;
    double xMeasured,yMeasured;
    double bottom;
    double xPhysical,yPhysical;

    // pixellength comes in in units of micron
    //convert pixelLength & pixelHeight into mm units so that
    //they are comparable with distance (in units of mm)
    pixelLength_mm = pixelLength/1000.0;
    pixelHeight_mm = pixelHeight/1000.0;
    
    xMeasured = (xPixel-xCenter)*pixelLength_mm;
    yMeasured = (yPixel-yCenter)*pixelHeight_mm;

    bottom = distance+(yMeasured*cos_rotation-xMeasured*sin_rotation)*sin_alpha+
            (xMeasured*cos_rotation+yMeasured*sin_rotation)*sin_beta;
        
    // calculate the x y cordinates on the imaginary detector using fancy math
    xPhysical = distance*(xMeasured*cos_rotation+yMeasured*sin_rotation)*cos_beta/bottom;
    yPhysical = distance*(yMeasured*cos_rotation-xMeasured*sin_rotation)*cos_alpha/bottom;

    *twoTheta = atan2(sqrt(xPhysical*xPhysical+yPhysical*yPhysical),distance);
    // Convert to radians
    *twoTheta = *twoTheta * 180.0/PI;

    // explicitly convert chi to degrees
    *chi=atan2(yPhysical,xPhysical)*180.0/PI;
    
    // then add rotation to it so that chi alwasy points to the right.
    // Also, we have to mulitply chi by -1 because we have been defining our
    // angles the invers of the way they should be. There is a probably a better
    // way to do this if I really thought through exactly how chi is defined.
    // For the moment, through, this does exactly the right thing.
    *chi = (*chi + rotation)*(-1);

    // make sure that chi is b/n 0 and 360
    *chi = mod(*chi, 360.0);
}
\end{lstlisting}
Listing~\ref{getXY} presents the function \code{getXY()} 
which does the inverse transformation of 
function~\ref{getTwoThetaChi}. It uses the same
terminology for parameters as that function.

\begin{lstlisting}[caption={The Code to convert $(Q,\chi)$ values into pixel coordinates on a real detector},label=getXY]
void getXY(double xCenter,double yCenter,double distance,double energy,
        double q,double chi,double pixelLength,double pixelHeight,
        double rotation,
        double cos_beta,double sin_beta,double cos_alpha,double sin_alpha,
        double cos_rotation,double sin_rotation,
        double * xPixel,double * yPixel) {

    double wavelength;
    double twoTheta;
    double xPhysical,yPhysical;
    double bottom;
    double pixelLength_mm,pixelHeight_mm;
    double xMeasured,yMeasured;

    double tan_chi;

    wavelength = 12398.4172/energy;

    // rotate chi back to point whatever way it is supposed to point
    chi = chi*(-1) - rotation;

    chi = mod(chi, 360.0);
    
    // explicitly convert chi to radians
    chi*=PI/180.0;

    twoTheta = 2.0*asin(wavelength*q/(4.0*PI));

    tan_chi = tan(chi);
    xPhysical = fabs(distance*tan(twoTheta)/sqrt(1.0+tan_chi*tan_chi));
    // one must determine explicitly the sign of xPhysical by inspecting the diagram.
    // This is b/c at one point we take a sqrt in our derivation.
    if (chi>PI/2.0 && chi<3.0*PI/2.0) 
        xPhysical = -1.0*xPhysical;

    yPhysical=fabs(xPhysical*tan_chi);

    // set the sign of y explicitly
    if (chi > PI && chi < 2.0*PI)
        yPhysical = -1.0*fabs(yPhysical);

    // I should worry about cos_alpha being 0
    bottom = distance*cos_beta-xPhysical*sin_beta-yPhysical*cos_beta*sin_alpha/cos_alpha;

    xMeasured = (xPhysical*distance*cos_rotation-yPhysical*distance*(cos_beta/cos_alpha)*sin_rotation)/bottom;
    yMeasured =  (xPhysical*distance*sin_rotation+yPhysical*distance*(cos_beta/cos_alpha)*cos_rotation)/bottom;

    // convert pixelLength & pixelHeight into mm units so that
    // they are comparable with distance (in units of mm)
    pixelLength_mm = pixelLength/1000.0;
    pixelHeight_mm = pixelHeight/1000.0;

    *xPixel = xMeasured/pixelLength_mm + xCenter;
    *yPixel = yMeasured/pixelHeight_mm + yCenter;
}
\end{lstlisting}
